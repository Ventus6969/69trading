"""
MLÊï∏ÊìöÁÆ°ÁêÜÊ®°ÁµÑ - ÂÆåÊï¥ÂäüËÉΩÁâàÊú¨
‰øÆÂæ©ÊâÄÊúâË®àÁÆóÂïèÈ°åÔºåÂØ¶ÁèæÁúüÊ≠£ÁöÑ36ÂÄãÁâπÂæµË®àÁÆóÂíåMLÂ≠∏ÁøíÂäüËÉΩ
=============================================================================
"""
import sqlite3
import logging
import time
import json
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List, Tuple
import numpy as np

# Ë®≠ÁΩÆlogger
logger = logging.getLogger(__name__)

class MLDataManager:
    """MLÊï∏ÊìöÁÆ°ÁêÜÈ°û - ÂÆåÊï¥ÂäüËÉΩÁâàÊú¨"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        # ÂàùÂßãÂåñMLË°®Ê†º
        self._init_ml_tables()
        logger.info(f"‚úÖ MLÊï∏ÊìöÁÆ°ÁêÜÂô®Â∑≤ÂàùÂßãÂåñÔºåË≥áÊñôÂ∫´Ë∑ØÂæë: {self.db_path}")
    
    def _init_ml_tables(self):
        """ÂàùÂßãÂåñMLÁõ∏ÈóúË°®Ê†º - Èò≤SQLiteÈéñÂÆöÁöÑÂÆåÁæéÁâàÊú¨"""
        max_retries = 3
        retry_delay = 1.0
        
        for attempt in range(max_retries):
            try:
                with sqlite3.connect(self.db_path, timeout=30.0) as conn:
                    cursor = conn.cursor()
                    
                    # üî• Á¨¨‰∏ÄÊ≠•ÔºöÁ¢∫‰øùÊúÄ‰Ω≥Ë≥áÊñôÂ∫´Ë®≠ÂÆö
                    cursor.execute('PRAGMA journal_mode = WAL')
                    cursor.execute('PRAGMA synchronous = NORMAL')
                    cursor.execute('PRAGMA cache_size = 10000')
                    cursor.execute('PRAGMA temp_store = MEMORY')
                    cursor.execute('PRAGMA busy_timeout = 30000')  # 30ÁßíË∂ÖÊôÇ
                    
                    # üî• Á¨¨‰∫åÊ≠•ÔºöÊ™¢Êü•ÁèæÊúâË°®Ê†º
                    cursor.execute("""
                        SELECT name FROM sqlite_master 
                        WHERE type='table' AND name IN ('ml_features_v2', 'ml_signal_quality', 'ml_price_optimization')
                    """)
                    existing_tables = [row[0] for row in cursor.fetchall()]
                    
                    if len(existing_tables) == 3:
                        logger.info("‚úÖ MLË°®Ê†ºÂ∑≤ÂÆåÊï¥Â≠òÂú®ÔºåË∑≥ÈÅéÂâµÂª∫")
                        # È©óË≠âË°®Ê†ºÁµêÊßã
                        cursor.execute("PRAGMA table_info(ml_features_v2)")
                        columns = cursor.fetchall()
                        if len(columns) >= 38:  # 36ÁâπÂæµ + id + session_id + signal_id + created_at
                            logger.info("‚úÖ MLË°®Ê†ºÁµêÊßãÈ©óË≠âÈÄöÈÅé")
                            return
                        else:
                            logger.warning(f"‚ö†Ô∏è MLË°®Ê†ºÁµêÊßã‰∏çÂÆåÊï¥ÔºåÈáçÊñ∞ÂâµÂª∫")
                    
                    # üî• Á¨¨‰∏âÊ≠•ÔºöÂâµÂª∫ÂÆåÊï¥ÁöÑMLË°®Ê†º
                    logger.info(f"Ê≠£Âú®ÂâµÂª∫MLË°®Ê†º... (ÁèæÊúâ: {len(existing_tables)}/3)")
                    
                    # 1. MLÁâπÂæµË°® (ÂÆåÊï¥36ÂÄãÁâπÂæµ)
                    cursor.execute('''
                        CREATE TABLE IF NOT EXISTS ml_features_v2 (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            session_id TEXT NOT NULL,
                            signal_id INTEGER,
                            
                            -- ‰ø°ËôüÂìÅË≥™Ê†∏ÂøÉÁâπÂæµ (15ÂÄã)
                            strategy_win_rate_recent REAL DEFAULT 0.0,
                            strategy_win_rate_overall REAL DEFAULT 0.0,
                            strategy_market_fitness REAL DEFAULT 0.0,
                            volatility_match_score REAL DEFAULT 0.0,
                            time_slot_match_score REAL DEFAULT 0.0,
                            symbol_match_score REAL DEFAULT 0.0,
                            price_momentum_strength REAL DEFAULT 0.0,
                            atr_relative_position REAL DEFAULT 0.0,
                            risk_reward_ratio REAL DEFAULT 0.0,
                            execution_difficulty REAL DEFAULT 0.0,
                            consecutive_win_streak INTEGER DEFAULT 0,
                            consecutive_loss_streak INTEGER DEFAULT 0,
                            system_overall_performance REAL DEFAULT 0.0,
                            signal_confidence_score REAL DEFAULT 0.0,
                            market_condition_fitness REAL DEFAULT 0.0,
                            
                            -- ÂÉπÊ†ºÈóú‰øÇÁâπÂæµ (12ÂÄã)
                            price_deviation_percent REAL DEFAULT 0.0,
                            price_deviation_abs REAL DEFAULT 0.0,
                            atr_normalized_deviation REAL DEFAULT 0.0,
                            candle_direction INTEGER DEFAULT 0,
                            candle_body_size REAL DEFAULT 0.0,
                            candle_wick_ratio REAL DEFAULT 0.0,
                            price_position_in_range REAL DEFAULT 0.0,
                            upward_adjustment_space REAL DEFAULT 0.0,
                            downward_adjustment_space REAL DEFAULT 0.0,
                            historical_best_adjustment REAL DEFAULT 0.0,
                            price_reachability_score REAL DEFAULT 0.0,
                            entry_price_quality_score REAL DEFAULT 0.0,
                            
                            -- Â∏ÇÂ†¥Áí∞Â¢ÉÁâπÂæµ (9ÂÄã)
                            hour_of_day INTEGER DEFAULT 0,
                            trading_session INTEGER DEFAULT 0,
                            weekend_factor INTEGER DEFAULT 0,
                            symbol_category INTEGER DEFAULT 0,
                            current_positions INTEGER DEFAULT 0,
                            margin_ratio REAL DEFAULT 0.0,
                            atr_normalized REAL DEFAULT 0.0,
                            volatility_regime INTEGER DEFAULT 0,
                            market_trend_strength REAL DEFAULT 0.0,
                            
                            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                            FOREIGN KEY (signal_id) REFERENCES signals_received (id)
                        )
                    ''')
                    
                    # 2. ML‰ø°ËôüÂìÅË≥™Ë®òÈåÑË°®
                    cursor.execute('''
                        CREATE TABLE IF NOT EXISTS ml_signal_quality (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            session_id TEXT NOT NULL,
                            signal_id INTEGER,
                            ml_recommendation TEXT NOT NULL,
                            confidence_score REAL,
                            execution_probability REAL,
                            trading_probability REAL,
                            risk_level TEXT,
                            decision_reason TEXT,
                            suggested_price_adjustment REAL DEFAULT 0.0,
                            actual_decision TEXT,
                            prediction_accuracy REAL,
                            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                            FOREIGN KEY (signal_id) REFERENCES signals_received (id)
                        )
                    ''')
                    
                    # 3. MLÂÉπÊ†ºÂÑ™ÂåñË®òÈåÑË°®
                    cursor.execute('''
                        CREATE TABLE IF NOT EXISTS ml_price_optimization (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            session_id TEXT NOT NULL,
                            signal_id INTEGER,
                            original_price REAL,
                            optimized_price REAL,
                            price_adjustment_percent REAL,
                            optimization_reason TEXT,
                            expected_improvement REAL,
                            confidence_level REAL,
                            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                            FOREIGN KEY (signal_id) REFERENCES signals_received (id)
                        )
                    ''')
                    
                    # ÂâµÂª∫Á¥¢Âºï
                    cursor.execute('CREATE INDEX IF NOT EXISTS idx_ml_features_signal_id ON ml_features_v2(signal_id)')
                    cursor.execute('CREATE INDEX IF NOT EXISTS idx_ml_features_session_id ON ml_features_v2(session_id)')
                    cursor.execute('CREATE INDEX IF NOT EXISTS idx_ml_quality_signal_id ON ml_signal_quality(signal_id)')
                    cursor.execute('CREATE INDEX IF NOT EXISTS idx_ml_price_signal_id ON ml_price_optimization(signal_id)')
                    
                    conn.commit()
                    logger.info("‚úÖ MLË≥áÊñôÂ∫´Ë°®Ê†ºÂàùÂßãÂåñÂÆåÊàê")
                    return
                    
            except sqlite3.OperationalError as e:
                if "database is locked" in str(e).lower() and attempt < max_retries - 1:
                    logger.warning(f"‚ö†Ô∏è Ë≥áÊñôÂ∫´Ë¢´ÈéñÂÆöÔºåÁ¨¨{attempt + 1}Ê¨°ÈáçË©¶ (Á≠âÂæÖ{retry_delay}Áßí)")
                    time.sleep(retry_delay)
                    retry_delay *= 1.5  # ÊåáÊï∏ÈÄÄÈÅø
                    continue
                else:
                    logger.error(f"‚ùå ÂàùÂßãÂåñMLË°®Ê†ºÂ§±Êïó: {str(e)}")
                    raise
            except Exception as e:
                logger.error(f"‚ùå ÂàùÂßãÂåñMLË°®Ê†ºÊôÇÂá∫ÈåØ: {str(e)}")
                if attempt < max_retries - 1:
                    logger.info(f"ÂòóË©¶Á¨¨{attempt + 2}Ê¨°ÂàùÂßãÂåñ...")
                    time.sleep(retry_delay)
                    continue
                else:
                    raise
        
        logger.error("‚ùå Â§öÊ¨°ÈáçË©¶Âæå‰ªçÁÑ°Ê≥ïÂàùÂßãÂåñMLË°®Ê†º")
        raise Exception("MLË°®Ê†ºÂàùÂßãÂåñÂ§±Êïó")
    
    def calculate_basic_features(self, signal_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Ë®àÁÆóÂÆåÊï¥ÁöÑ36ÂÄãMLÁâπÂæµ - ÁúüÊ≠£ÁöÑÂØ¶ÁèæÁâàÊú¨
        
        Args:
            signal_data: ÂéüÂßã‰ø°ËôüÊï∏Êìö
            
        Returns:
            Dict: 36ÂÄãÁâπÂæµÁöÑÂÆåÊï¥Â≠óÂÖ∏
        """
        features = {}
        
        try:
            logger.info(f"üß† ÈñãÂßãË®àÁÆó36ÂÄãMLÁâπÂæµ...")
            
            # üî• ÂÆâÂÖ®ÁöÑÊï∏ÂÄºËΩâÊèõÂáΩÊï∏
            def safe_float(value, default=0.0):
                try:
                    if value is None:
                        return float(default)
                    if isinstance(value, (int, float)):
                        return float(value)
                    str_value = str(value).replace(',', '').replace(' ', '').strip()
                    if str_value == '' or str_value == 'None':
                        return float(default)
                    return float(str_value)
                except (ValueError, TypeError):
                    return float(default)
            
            def safe_int(value, default=0):
                try:
                    if value is None:
                        return int(default)
                    return int(float(str(value).replace(',', '').replace(' ', '').strip()))
                except (ValueError, TypeError):
                    return int(default)
            
            # ÊèêÂèñÂü∫Á§é‰ø°ËôüÊï∏Êìö
            symbol = signal_data.get('symbol', '')
            signal_type = signal_data.get('signal_type', '')
            opposite = safe_int(signal_data.get('opposite', 0))
            side = signal_data.get('side', '')
            open_price = safe_float(signal_data.get('open', 0))
            close_price = safe_float(signal_data.get('close', 0))
            prev_close = safe_float(signal_data.get('prev_close', 0))
            prev_open = safe_float(signal_data.get('prev_open', 0))
            atr = safe_float(signal_data.get('ATR', 0))
            
            # === Á¨¨‰∏ÄÈ°ûÔºö‰ø°ËôüÂìÅË≥™Ê†∏ÂøÉÁâπÂæµ (15ÂÄã) ===
            
            # 1-2. Á≠ñÁï•ÂãùÁéáÂàÜÊûê
            recent_win_rate, overall_win_rate = self._calculate_strategy_win_rates(signal_type, opposite)
            features['strategy_win_rate_recent'] = recent_win_rate
            features['strategy_win_rate_overall'] = overall_win_rate
            
            # 3. Á≠ñÁï•Â∏ÇÂ†¥ÈÅ©ÊáâÊÄß
            features['strategy_market_fitness'] = self._calculate_market_fitness(signal_type, symbol, atr)
            
            # 4. Ê≥¢ÂãïÁéáÂåπÈÖçÂ∫¶
            features['volatility_match_score'] = self._calculate_volatility_match(atr, symbol)
            
            # 5. ÊôÇÊÆµÂåπÈÖçÂ∫¶
            features['time_slot_match_score'] = self._calculate_time_slot_match()
            
            # 6. ‰∫§ÊòìÂ∞çÂåπÈÖçÂ∫¶
            features['symbol_match_score'] = self._calculate_symbol_match(symbol, signal_type)
            
            # 7. ÂÉπÊ†ºÂãïÈáèÂº∑Â∫¶
            features['price_momentum_strength'] = self._calculate_price_momentum(open_price, close_price, prev_close)
            
            # 8. ATRÁõ∏Â∞ç‰ΩçÁΩÆ
            features['atr_relative_position'] = self._calculate_atr_position(atr, symbol)
            
            # 9. È¢®Èö™ÂõûÂ†±ÊØî
            features['risk_reward_ratio'] = self._calculate_risk_reward_ratio(atr, signal_type)
            
            # 10. Âü∑Ë°åÈõ£Â∫¶
            features['execution_difficulty'] = self._calculate_execution_difficulty(signal_type, opposite, atr)
            
            # 11-12. ÈÄ£Á∫åÂãùË≤†Ê¨°Êï∏
            win_streak, loss_streak = self._calculate_streak_counts(signal_type)
            features['consecutive_win_streak'] = win_streak
            features['consecutive_loss_streak'] = loss_streak
            
            # 13. Á≥ªÁµ±Êï¥È´îË°®Áèæ
            features['system_overall_performance'] = self._calculate_system_performance()
            
            # 14. ‰ø°Ëôü‰ø°ÂøÉÂ∫¶
            features['signal_confidence_score'] = self._calculate_signal_confidence(features)
            
            # 15. Â∏ÇÂ†¥ÁãÄÊ≥ÅÈÅ©ÊáâÊÄß
            features['market_condition_fitness'] = self._calculate_market_condition_fitness(atr, features['hour_of_day'])
            
            # === Á¨¨‰∫åÈ°ûÔºöÂÉπÊ†ºÈóú‰øÇÁâπÂæµ (12ÂÄã) ===
            
            # 16-17. ÂÉπÊ†ºÂÅèÂ∑ÆÂàÜÊûê
            price_deviation = self._calculate_price_deviation(open_price, close_price, opposite)
            features['price_deviation_percent'] = price_deviation['percent']
            features['price_deviation_abs'] = price_deviation['absolute']
            
            # 18. ATRÊ®ôÊ∫ñÂåñÂÅèÂ∑Æ
            features['atr_normalized_deviation'] = abs(price_deviation['absolute']) / max(atr, 0.001)
            
            # 19. KÁ∑öÊñπÂêë
            features['candle_direction'] = 1 if close_price > open_price else (-1 if close_price < open_price else 0)
            
            # 20. KÁ∑öÂØ¶È´îÂ§ßÂ∞è
            features['candle_body_size'] = abs(close_price - open_price) / max(open_price, 0.001)
            
            # 21. KÁ∑öÂΩ±Á∑öÊØî‰æã
            high_price = max(open_price, close_price)
            low_price = min(open_price, close_price)
            total_range = max(high_price - low_price, 0.001)
            body_size = abs(close_price - open_price)
            features['candle_wick_ratio'] = (total_range - body_size) / total_range
            
            # 22. ÂÉπÊ†ºÂú®ÂçÄÈñì‰ΩçÁΩÆ
            features['price_position_in_range'] = self._calculate_price_position(close_price, high_price, low_price)
            
            # 23-24. ÂÉπÊ†ºË™øÊï¥Á©∫Èñì
            adjustment_space = self._calculate_adjustment_space(close_price, atr)
            features['upward_adjustment_space'] = adjustment_space['upward']
            features['downward_adjustment_space'] = adjustment_space['downward']
            
            # 25. Ê≠∑Âè≤ÊúÄ‰Ω≥Ë™øÊï¥
            features['historical_best_adjustment'] = self._calculate_historical_adjustment(signal_type, symbol)
            
            # 26. ÂÉπÊ†ºÂèØÈÅîÊÄßÂàÜÊï∏
            features['price_reachability_score'] = self._calculate_price_reachability(close_price, atr, side)
            
            # 27. ÈñãÂÄâÂÉπÊ†ºÂìÅË≥™ÂàÜÊï∏
            features['entry_price_quality_score'] = self._calculate_entry_price_quality(features)
            
            # === Á¨¨‰∏âÈ°ûÔºöÂ∏ÇÂ†¥Áí∞Â¢ÉÁâπÂæµ (9ÂÄã) ===
            
            # 28. Áï∂ÂâçÂ∞èÊôÇ
            current_hour = datetime.now().hour
            features['hour_of_day'] = current_hour
            
            # 29. ‰∫§ÊòìÊôÇÊÆµ
            features['trading_session'] = self._get_trading_session(current_hour)
            
            # 30. ÈÄ±Êú´Âõ†Â≠ê
            features['weekend_factor'] = 1 if datetime.now().weekday() >= 5 else 0
            
            # 31. ‰∫§ÊòìÂ∞çÂàÜÈ°û
            features['symbol_category'] = self._get_symbol_category(symbol)
            
            # 32. Áï∂ÂâçÊåÅÂÄâÊï∏
            features['current_positions'] = self._get_current_positions_count()
            
            # 33. ‰øùË≠âÈáëÊØî‰æã
            features['margin_ratio'] = self._calculate_margin_ratio()
            
            # 34. ATRÊ®ôÊ∫ñÂåñ
            features['atr_normalized'] = self._normalize_atr(atr, symbol)
            
            # 35. Ê≥¢ÂãïÁéáÂà∂Â∫¶
            features['volatility_regime'] = self._get_volatility_regime(atr, symbol)
            
            # 36. Â∏ÇÂ†¥Ë∂®Âã¢Âº∑Â∫¶
            features['market_trend_strength'] = self._calculate_trend_strength(open_price, close_price, prev_close)
            
            # È©óË≠âÊâÄÊúâÁâπÂæµÈÉΩÂ∑≤Ë®àÁÆó
            expected_features = 36
            actual_features = len([k for k, v in features.items() if v is not None])
            
            logger.info(f"‚úÖ MLÁâπÂæµË®àÁÆóÂÆåÊàê: {actual_features}/{expected_features} ÂÄãÁâπÂæµ")
            
            if actual_features != expected_features:
                missing_features = expected_features - actual_features
                logger.warning(f"‚ö†Ô∏è Áº∫Â∞ë {missing_features} ÂÄãÁâπÂæµÔºå‰ΩøÁî®ÈªòË™çÂÄºË£úÈΩä")
                features.update(self._get_default_features())
            
            return features
                
        except Exception as e:
            logger.error(f"‚ùå Ë®àÁÆóMLÁâπÂæµÊôÇÂá∫ÈåØ: {str(e)}")
            logger.error(f"ÈåØË™§‰ø°ËôüÊï∏Êìö: {signal_data}")
            # ËøîÂõûÈªòË™çÁâπÂæµÁ¢∫‰øùÁ≥ªÁµ±ÁπºÁ∫åÈÅãË°å
            return self._get_default_features()
    
    def _calculate_strategy_win_rates(self, signal_type: str, opposite: int) -> Tuple[float, float]:
        """Ë®àÁÆóÁ≠ñÁï•ÂãùÁéáÔºàÊúÄËøë30Â§©ÂíåÁ∏ΩÈ´îÔºâ"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # ÊúÄËøë30Â§©ÂãùÁéá
                thirty_days_ago = time.time() - (30 * 24 * 3600)
                cursor.execute('''
                    SELECT 
                        COUNT(*) as total,
                        SUM(CASE WHEN tr.is_successful = 1 THEN 1 ELSE 0 END) as wins
                    FROM signals_received sr
                    JOIN orders_executed oe ON sr.id = oe.signal_id
                    JOIN trading_results tr ON oe.id = tr.order_id
                    WHERE sr.signal_type = ? AND sr.opposite = ? AND sr.timestamp > ?
                ''', (signal_type, opposite, thirty_days_ago))
                
                recent_data = cursor.fetchone()
                recent_total, recent_wins = recent_data if recent_data else (0, 0)
                recent_win_rate = recent_wins / max(recent_total, 1)
                
                # Á∏ΩÈ´îÂãùÁéá
                cursor.execute('''
                    SELECT 
                        COUNT(*) as total,
                        SUM(CASE WHEN tr.is_successful = 1 THEN 1 ELSE 0 END) as wins
                    FROM signals_received sr
                    JOIN orders_executed oe ON sr.id = oe.signal_id
                    JOIN trading_results tr ON oe.id = tr.order_id
                    WHERE sr.signal_type = ? AND sr.opposite = ?
                ''', (signal_type, opposite))
                
                overall_data = cursor.fetchone()
                overall_total, overall_wins = overall_data if overall_data else (0, 0)
                overall_win_rate = overall_wins / max(overall_total, 1)
                
                return recent_win_rate, overall_win_rate
                
        except Exception as e:
            logger.warning(f"Ë®àÁÆóÁ≠ñÁï•ÂãùÁéáÊôÇÂá∫ÈåØ: {str(e)}")
            return 0.5, 0.5
    
    def _calculate_market_fitness(self, signal_type: str, symbol: str, atr: float) -> float:
        """Ë®àÁÆóÁ≠ñÁï•Â∏ÇÂ†¥ÈÅ©ÊáâÊÄß"""
        try:
            # Âü∫ÊñºÁ≠ñÁï•È°ûÂûãÂíåÂ∏ÇÂ†¥Ê≥¢ÂãïÁöÑÈÅ©ÊáâÊÄßË©ïÂàÜ
            strategy_volatility_preferences = {
                'breakout_buy': {'min_atr': 0.02, 'max_atr': 0.08, 'optimal': 0.04},
                'trend_sell': {'min_atr': 0.01, 'max_atr': 0.06, 'optimal': 0.03},
                'reversal_buy': {'min_atr': 0.015, 'max_atr': 0.05, 'optimal': 0.025},
                'bounce_buy': {'min_atr': 0.02, 'max_atr': 0.07, 'optimal': 0.035}
            }
            
            if signal_type in strategy_volatility_preferences:
                prefs = strategy_volatility_preferences[signal_type]
                optimal_atr = prefs['optimal']
                deviation = abs(atr - optimal_atr) / optimal_atr
                fitness = max(0.1, 1.0 - deviation)
                return min(1.0, fitness)
            
            return 0.5
            
        except Exception:
            return 0.5
    
    def _calculate_volatility_match(self, atr: float, symbol: str) -> float:
        """Ë®àÁÆóÊ≥¢ÂãïÁéáÂåπÈÖçÂ∫¶"""
        try:
            # ‰∏çÂêå‰∫§ÊòìÂ∞çÁöÑÊ®ôÊ∫ñATRÁØÑÂúç
            symbol_atr_ranges = {
                'BTCUSDT': {'low': 0.015, 'high': 0.06},
                'ETHUSDT': {'low': 0.02, 'high': 0.08},
                'BNBUSDT': {'low': 0.025, 'high': 0.1},
                'ADAUSDT': {'low': 0.03, 'high': 0.12}
            }
            
            if symbol in symbol_atr_ranges:
                range_info = symbol_atr_ranges[symbol]
                if range_info['low'] <= atr <= range_info['high']:
                    # Âú®Ê≠£Â∏∏ÁØÑÂúçÂÖßÔºåË®àÁÆóÁõ∏Â∞ç‰ΩçÁΩÆ
                    range_span = range_info['high'] - range_info['low']
                    position = (atr - range_info['low']) / range_span
                    # ‰∏≠Á≠âÊ≥¢ÂãïÁéáÂæóÂàÜËºÉÈ´ò
                    return 1.0 - abs(position - 0.5) * 2
                else:
                    # Ë∂ÖÂá∫Ê≠£Â∏∏ÁØÑÂúç
                    return 0.3
            
            return 0.5
            
        except Exception:
            return 0.5
    
    def _calculate_time_slot_match(self) -> float:
        """Ë®àÁÆóÊôÇÊÆµÂåπÈÖçÂ∫¶"""
        try:
            current_hour = datetime.now().hour
            
            # Ê†πÊìö‰∫§ÊòìÊ¥ªË∫çÊôÇÊÆµË©ïÂàÜ
            if 8 <= current_hour <= 12:  # ‰∫ûÊ¥≤ÊôÇÊÆµ
                return 0.7
            elif 13 <= current_hour <= 17:  # Ê≠êÊ¥≤ÊôÇÊÆµ
                return 0.9
            elif 18 <= current_hour <= 22:  # ÁæéÂúãÊôÇÊÆµ
                return 0.8
            elif 1 <= current_hour <= 6:   # Ê∑±Â§úÊôÇÊÆµ
                return 0.4
            else:  # ÂÖ∂‰ªñÊôÇÊÆµ
                return 0.6
                
        except Exception:
            return 0.6
    
    def _calculate_symbol_match(self, symbol: str, signal_type: str) -> float:
        """Ë®àÁÆó‰∫§ÊòìÂ∞çÂåπÈÖçÂ∫¶"""
        try:
            # ‰∏çÂêåÁ≠ñÁï•Â∞ç‰∏çÂêå‰∫§ÊòìÂ∞çÁöÑÈÅ©ÊáâÊÄß
            strategy_symbol_preferences = {
                'breakout_buy': ['BTCUSDT', 'ETHUSDT'],
                'trend_sell': ['BTCUSDT', 'BNBUSDT'],
                'reversal_buy': ['ETHUSDT', 'ADAUSDT'],
                'bounce_buy': ['BTCUSDT', 'ETHUSDT', 'BNBUSDT']
            }
            
            if signal_type in strategy_symbol_preferences:
                preferred_symbols = strategy_symbol_preferences[signal_type]
                if symbol in preferred_symbols:
                    return 0.8
                else:
                    return 0.4
            
            return 0.6
            
        except Exception:
            return 0.6
    
    def _calculate_price_momentum(self, open_price: float, close_price: float, prev_close: float) -> float:
        """Ë®àÁÆóÂÉπÊ†ºÂãïÈáèÂº∑Â∫¶"""
        try:
            if prev_close <= 0:
                return 0.0
            
            # Áï∂ÂâçKÁ∑öËÆäÂåñ
            current_change = (close_price - open_price) / open_price
            # ËàáÂâç‰∏ÄÊ†πÁöÑÈóú‰øÇ
            gap_change = (open_price - prev_close) / prev_close
            
            # Á∂úÂêàÂãïÈáèÂº∑Â∫¶
            momentum = abs(current_change) + abs(gap_change) * 0.5
            return min(1.0, momentum * 10)  # Ê®ôÊ∫ñÂåñÂà∞0-1
            
        except Exception:
            return 0.0
    
    def _calculate_atr_position(self, atr: float, symbol: str) -> float:
        """Ë®àÁÆóATRÁõ∏Â∞ç‰ΩçÁΩÆ"""
        try:
            # Áç≤ÂèñË©≤‰∫§ÊòìÂ∞çÁöÑATRÊ≠∑Âè≤ÂàÜ‰ΩçÊï∏
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                cursor.execute('''
                    SELECT atr_value FROM signals_received 
                    WHERE symbol = ? AND atr_value > 0 
                    ORDER BY timestamp DESC LIMIT 100
                ''', (symbol,))
                
                atr_history = [row[0] for row in cursor.fetchall()]
                
                if len(atr_history) > 10:
                    atr_history.sort()
                    percentile = len([x for x in atr_history if x <= atr]) / len(atr_history)
                    return percentile
                else:
                    return 0.5
                    
        except Exception:
            return 0.5
    
    def _calculate_risk_reward_ratio(self, atr: float, signal_type: str) -> float:
        """Ë®àÁÆóÈ¢®Èö™ÂõûÂ†±ÊØî"""
        try:
            # ‰∏çÂêåÁ≠ñÁï•ÁöÑÊ®ôÊ∫ñÈ¢®Èö™ÂõûÂ†±ÊØî
            strategy_rr_ratios = {
                'breakout_buy': 2.5,
                'trend_sell': 3.0,
                'reversal_buy': 2.0,
                'bounce_buy': 2.2,
                'consolidation_buy': 1.8
            }
            
            base_rr = strategy_rr_ratios.get(signal_type, 2.5)
            
            # Ê†πÊìöATRË™øÊï¥ÔºàÈ´òÊ≥¢ÂãïÁéáÈôç‰ΩéRRÔºå‰ΩéÊ≥¢ÂãïÁéáÊèêÈ´òRRÔºâ
            if atr > 0.05:
                adjustment = 0.8  # È´òÊ≥¢ÂãïÁéáÔºåÈôç‰ΩéÊúüÊúõRR
            elif atr < 0.02:
                adjustment = 1.2  # ‰ΩéÊ≥¢ÂãïÁéáÔºåÂèØ‰ª•ÊúüÊúõÊõ¥È´òRR
            else:
                adjustment = 1.0
            
            return base_rr * adjustment
            
        except Exception:
            return 2.5
    
    def _calculate_execution_difficulty(self, signal_type: str, opposite: int, atr: float) -> float:
        """Ë®àÁÆóÂü∑Ë°åÈõ£Â∫¶"""
        try:
            # Âü∫Á§éÈõ£Â∫¶Ë©ïÂàÜ
            base_difficulty = {
                'breakout_buy': 0.3,    # Á™ÅÁ†¥Áõ∏Â∞çÂÆπÊòìÂü∑Ë°å
                'trend_sell': 0.2,      # È†ÜÂã¢ÊúÄÂÆπÊòì
                'reversal_buy': 0.7,    # ÂèçËΩâËºÉÈõ£
                'bounce_buy': 0.4,      # ÂèçÂΩà‰∏≠Á≠âÈõ£Â∫¶
                'consolidation_buy': 0.8  # Êï¥ÁêÜÊúüÊúÄÈõ£
            }.get(signal_type, 0.5)
            
            # oppositeË™øÊï¥Ôºà2=ÂâçÊ†πÈñãÁõ§ÂÉπÔºåÂü∑Ë°åÈõ£Â∫¶ÊúÄÈ´òÔºâ
            opposite_adjustment = {0: 0.0, 1: 0.1, 2: 0.3}.get(opposite, 0.2)
            
            # ATRË™øÊï¥ÔºàÈ´òÊ≥¢ÂãïÁéáÂ¢ûÂä†Âü∑Ë°åÈõ£Â∫¶Ôºâ
            atr_adjustment = min(0.3, atr * 5)
            
            total_difficulty = min(1.0, base_difficulty + opposite_adjustment + atr_adjustment)
            return total_difficulty
            
        except Exception:
            return 0.5
    
    def _calculate_streak_counts(self, signal_type: str) -> Tuple[int, int]:
        """Ë®àÁÆóÈÄ£Á∫åÂãùË≤†Ê¨°Êï∏"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Áç≤ÂèñË©≤Á≠ñÁï•ÊúÄËøëÁöÑ‰∫§ÊòìÁµêÊûú
                cursor.execute('''
                    SELECT tr.is_successful
                    FROM signals_received sr
                    JOIN orders_executed oe ON sr.id = oe.signal_id
                    JOIN trading_results tr ON oe.id = tr.order_id
                    WHERE sr.signal_type = ?
                    ORDER BY sr.timestamp DESC LIMIT 20
                ''', (signal_type,))
                
                results = [row[0] for row in cursor.fetchall()]
                
                if not results:
                    return 0, 0
                
                # Ë®àÁÆóÁï∂ÂâçÈÄ£Á∫åÂãùË≤†
                current_streak_wins = 0
                current_streak_losses = 0
                
                for result in results:
                    if result == 1:  # ÂãùÂà©
                        if current_streak_losses == 0:
                            current_streak_wins += 1
                        else:
                            break
                    else:  # Â§±Êïó
                        if current_streak_wins == 0:
                            current_streak_losses += 1
                        else:
                            break
                
                return current_streak_wins, current_streak_losses
                
        except Exception:
            return 0, 0
    
    def _calculate_system_performance(self) -> float:
        """Ë®àÁÆóÁ≥ªÁµ±Êï¥È´îË°®Áèæ"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Áç≤ÂèñÊúÄËøë7Â§©ÁöÑÊï¥È´îË°®Áèæ
                seven_days_ago = time.time() - (7 * 24 * 3600)
                cursor.execute('''
                    SELECT 
                        COUNT(*) as total,
                        SUM(CASE WHEN is_successful = 1 THEN 1 ELSE 0 END) as wins,
                        AVG(pnl_percentage) as avg_pnl
                    FROM trading_results tr
                    JOIN orders_executed oe ON tr.order_id = oe.id
                    WHERE oe.execution_timestamp > ?
                ''', (seven_days_ago,))
                
                result = cursor.fetchone()
                if result and result[0] > 0:
                    total, wins, avg_pnl = result
                    win_rate = wins / total
                    pnl_factor = max(0, min(1, (avg_pnl or 0) / 5 + 0.5))  # Ê®ôÊ∫ñÂåñPNL
                    performance = (win_rate * 0.7) + (pnl_factor * 0.3)
                    return performance
                else:
                    return 0.5
                    
        except Exception:
            return 0.5
    
    def _calculate_signal_confidence(self, features: Dict[str, Any]) -> float:
        """Ë®àÁÆó‰ø°Ëôü‰ø°ÂøÉÂ∫¶ÔºàÂü∫ÊñºÂÖ∂‰ªñÁâπÂæµÁöÑÁ∂úÂêàË©ïÂàÜÔºâ"""
        try:
            # Ê¨äÈáçÂåñÈóúÈçµÁâπÂæµ
            confidence_factors = [
                features.get('strategy_win_rate_recent', 0.5) * 0.3,
                features.get('volatility_match_score', 0.5) * 0.2,
                features.get('time_slot_match_score', 0.5) * 0.15,
                features.get('symbol_match_score', 0.5) * 0.15,
                (1.0 - features.get('execution_difficulty', 0.5)) * 0.2
            ]
            
            confidence = sum(confidence_factors)
            return min(1.0, max(0.1, confidence))
            
        except Exception:
            return 0.5
    
    def _calculate_market_condition_fitness(self, atr: float, hour: int) -> float:
        """Ë®àÁÆóÂ∏ÇÂ†¥ÁãÄÊ≥ÅÈÅ©ÊáâÊÄß"""
        try:
            # ÊôÇÊÆµÂõ†Â≠ê
            time_factor = 0.7 if 8 <= hour <= 22 else 0.4
            
            # Ê≥¢ÂãïÁéáÂõ†Â≠êÔºà‰∏≠Á≠âÊ≥¢ÂãïÁéáÊúÄ‰Ω≥Ôºâ
            volatility_factor = 1.0 - abs(atr - 0.03) / 0.03 if atr <= 0.06 else 0.3
            volatility_factor = max(0.1, min(1.0, volatility_factor))
            
            # Á∂úÂêàÈÅ©ÊáâÊÄß
            fitness = (time_factor * 0.6) + (volatility_factor * 0.4)
            return fitness
            
        except Exception:
            return 0.5
    
    def _calculate_price_deviation(self, open_price: float, close_price: float, opposite: int) -> Dict[str, float]:
        """Ë®àÁÆóÂÉπÊ†ºÂÅèÂ∑Æ"""
        try:
            reference_price = close_price  # Âü∫Ê∫ñÂÉπÊ†º
            
            if opposite == 1:  # ÂâçÊ†πÊî∂Áõ§ÂÉπ
                # ÈÄôË£°ÊáâË©≤Áî®ÂØ¶ÈöõÁöÑÂâçÊ†πÊî∂Áõ§ÂÉπÔºåÊö´ÊôÇÁî®close_price
                deviation = 0.0
            elif opposite == 2:  # ÂâçÊ†πÈñãÁõ§ÂÉπ
                deviation = (open_price - close_price) / close_price if close_price > 0 else 0.0
            else:  # Áï∂ÂâçÊî∂Áõ§ÂÉπ
                deviation = 0.0
            
            return {
                'percent': deviation,
                'absolute': abs(deviation * close_price) if close_price > 0 else 0.0
            }
            
        except Exception:
            return {'percent': 0.0, 'absolute': 0.0}
    
    def _calculate_price_position(self, close_price: float, high_price: float, low_price: float) -> float:
        """Ë®àÁÆóÂÉπÊ†ºÂú®ÂçÄÈñì‰∏≠ÁöÑ‰ΩçÁΩÆ"""
        try:
            if high_price <= low_price:
                return 0.5
            
            position = (close_price - low_price) / (high_price - low_price)
            return max(0.0, min(1.0, position))
            
        except Exception:
            return 0.5
    
    def _calculate_adjustment_space(self, close_price: float, atr: float) -> Dict[str, float]:
        """Ë®àÁÆóÂÉπÊ†ºË™øÊï¥Á©∫Èñì"""
        try:
            if close_price <= 0 or atr <= 0:
                return {'upward': 0.02, 'downward': 0.02}
            
            # Âü∫ÊñºATRË®àÁÆóË™øÊï¥Á©∫Èñì
            upward_space = atr / close_price
            downward_space = atr / close_price
            
            return {
                'upward': min(0.05, max(0.01, upward_space)),
                'downward': min(0.05, max(0.01, downward_space))
            }
            
        except Exception:
            return {'upward': 0.02, 'downward': 0.02}
    
    def _calculate_historical_adjustment(self, signal_type: str, symbol: str) -> float:
        """Ë®àÁÆóÊ≠∑Âè≤ÊúÄ‰Ω≥Ë™øÊï¥"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Êü•ÊâæÊ≠∑Âè≤‰∏äË©≤Á≠ñÁï•+‰∫§ÊòìÂ∞çÁöÑÊúÄ‰Ω≥Ë™øÊï¥
                cursor.execute('''
                    SELECT AVG(price_adjustment_percent)
                    FROM ml_price_optimization mpo
                    JOIN signals_received sr ON mpo.signal_id = sr.id
                    WHERE sr.signal_type = ? AND sr.symbol = ? AND mpo.expected_improvement > 0
                ''', (signal_type, symbol))
                
                result = cursor.fetchone()
                if result and result[0] is not None:
                    return float(result[0])
                else:
                    return 0.0
                    
        except Exception:
            return 0.0
    
    def _calculate_price_reachability(self, close_price: float, atr: float, side: str) -> float:
        """Ë®àÁÆóÂÉπÊ†ºÂèØÈÅîÊÄßÂàÜÊï∏"""
        try:
            # Âü∫ÊñºATRÂíåÊñπÂêëË®àÁÆóÂÉπÊ†ºÂèØÈÅîÊÄß
            if atr <= 0:
                return 0.7
            
            # ‰∏çÂêåÊñπÂêëÁöÑÂèØÈÅîÊÄß‰∏çÂêå
            if side.upper() == 'BUY':
                # Ë≤∑ÂÖ•‰ø°ËôüÔºåËÄÉÊÖÆ‰∏äÊº≤ÂèØÈÅîÊÄß
                reachability = min(1.0, 0.5 + (atr / close_price) * 20)
            else:
                # Ë≥£Âá∫‰ø°ËôüÔºåËÄÉÊÖÆ‰∏ãË∑åÂèØÈÅîÊÄß
                reachability = min(1.0, 0.5 + (atr / close_price) * 15)
            
            return reachability
            
        except Exception:
            return 0.7
    
    def _calculate_entry_price_quality(self, features: Dict[str, Any]) -> float:
        """Ë®àÁÆóÈñãÂÄâÂÉπÊ†ºÂìÅË≥™ÂàÜÊï∏"""
        try:
            # Âü∫ÊñºÂ§öÂÄãÂõ†Â≠êÁöÑÁ∂úÂêàË©ïÂàÜ
            quality_factors = [
                features.get('price_reachability_score', 0.7) * 0.3,
                (1.0 - features.get('atr_normalized_deviation', 0.5)) * 0.25,
                features.get('price_position_in_range', 0.5) * 0.2,
                features.get('volatility_match_score', 0.5) * 0.25
            ]
            
            quality = sum(quality_factors)
            return min(1.0, max(0.1, quality))
            
        except Exception:
            return 0.6
    
    def _get_trading_session(self, hour: int) -> int:
        """Áç≤Âèñ‰∫§ÊòìÊôÇÊÆµ"""
        if 0 <= hour <= 6:
            return 1  # Ê∑±Â§úÊôÇÊÆµ
        elif 7 <= hour <= 12:
            return 2  # ‰∫ûÊ¥≤ÊôÇÊÆµ
        elif 13 <= hour <= 17:
            return 3  # Ê≠êÊ¥≤ÊôÇÊÆµ
        elif 18 <= hour <= 23:
            return 4  # ÁæéÂúãÊôÇÊÆµ
        else:
            return 1
    
    def _get_symbol_category(self, symbol: str) -> int:
        """Áç≤Âèñ‰∫§ÊòìÂ∞çÂàÜÈ°û"""
        try:
            if symbol in ['BTCUSDT']:
                return 1  # ÊØîÁâπÂπ£
            elif symbol in ['ETHUSDT']:
                return 2  # ‰ª•Â§™Âùä
            elif symbol in ['BNBUSDT', 'ADAUSDT', 'DOTUSDT', 'LINKUSDT', 'SOLUSDT', 'AVAXUSDT']:
                return 3  # ‰∏ªÊµÅÂπ£
            else:
                return 4  # Â±±ÂØ®Âπ£
        except:
            return 4
    
    def _get_current_positions_count(self) -> int:
        """Áç≤ÂèñÁï∂ÂâçÊåÅÂÄâÊï∏Èáè"""
        try:
            # ÈÄôË£°ÊáâË©≤Ë™øÁî®binance_clientÁç≤ÂèñÂØ¶ÈöõÊåÅÂÄâ
            # Êö´ÊôÇËøîÂõûÊ®°Êì¨Êï∏Êìö
            return 0
        except Exception:
            return 0
    
    def _calculate_margin_ratio(self) -> float:
        """Ë®àÁÆó‰øùË≠âÈáëÊØî‰æã"""
        try:
            # ÈÄôË£°ÊáâË©≤Áç≤ÂèñÂØ¶ÈöõÁöÑ‰øùË≠âÈáë‰ΩøÁî®Áéá
            # Êö´ÊôÇËøîÂõûÂÆâÂÖ®ÁöÑÈªòË™çÂÄº
            return 0.5
        except Exception:
            return 0.5
    
    def _normalize_atr(self, atr: float, symbol: str) -> float:
        """Ê®ôÊ∫ñÂåñATRÂÄº"""
        try:
            # ‰∏çÂêå‰∫§ÊòìÂ∞çÁöÑATRÊ®ôÊ∫ñÂåñ
            symbol_atr_standards = {
                'BTCUSDT': 0.03,
                'ETHUSDT': 0.04,
                'BNBUSDT': 0.05,
                'ADAUSDT': 0.06
            }
            
            standard = symbol_atr_standards.get(symbol, 0.04)
            return atr / standard
            
        except Exception:
            return 1.0
    
    def _get_volatility_regime(self, atr: float, symbol: str) -> int:
        """Áç≤ÂèñÊ≥¢ÂãïÁéáÂà∂Â∫¶"""
        try:
            normalized_atr = self._normalize_atr(atr, symbol)
            
            if normalized_atr < 0.7:
                return 1  # ‰ΩéÊ≥¢Âãï
            elif normalized_atr < 1.5:
                return 2  # ‰∏≠Ê≥¢Âãï
            else:
                return 3  # È´òÊ≥¢Âãï
                
        except Exception:
            return 2
    
    def _calculate_trend_strength(self, open_price: float, close_price: float, prev_close: float) -> float:
        """Ë®àÁÆóÂ∏ÇÂ†¥Ë∂®Âã¢Âº∑Â∫¶"""
        try:
            if prev_close <= 0:
                return 0.5
            
            # Ë®àÁÆóË∂®Âã¢Âº∑Â∫¶
            current_momentum = abs(close_price - open_price) / open_price
            gap_momentum = abs(open_price - prev_close) / prev_close
            
            trend_strength = (current_momentum + gap_momentum) / 2
            return min(1.0, trend_strength * 20)  # Ê®ôÊ∫ñÂåñ
            
        except Exception:
            return 0.5
    
    def _get_default_features(self) -> Dict[str, Any]:
        """Áç≤ÂèñÂÆâÂÖ®ÁöÑÈªòË™çÁâπÂæµÂÄº - Á¢∫‰øù36ÂÄãÁâπÂæµ"""
        return {
            # ‰ø°ËôüÂìÅË≥™Ê†∏ÂøÉÁâπÂæµ (15ÂÄã)
            'strategy_win_rate_recent': 0.5,
            'strategy_win_rate_overall': 0.5,
            'strategy_market_fitness': 0.5,
            'volatility_match_score': 0.5,
            'time_slot_match_score': 0.5,
            'symbol_match_score': 0.5,
            'price_momentum_strength': 0.5,
            'atr_relative_position': 0.5,
            'risk_reward_ratio': 2.5,
            'execution_difficulty': 0.5,
            'consecutive_win_streak': 0,
            'consecutive_loss_streak': 0,
            'system_overall_performance': 0.5,
            'signal_confidence_score': 0.5,
            'market_condition_fitness': 0.5,
            # ÂÉπÊ†ºÈóú‰øÇÁâπÂæµ (12ÂÄã)
            'price_deviation_percent': 0.0,
            'price_deviation_abs': 0.0,
            'atr_normalized_deviation': 0.0,
            'candle_direction': 0,
            'candle_body_size': 0.0,
            'candle_wick_ratio': 0.5,
            'price_position_in_range': 0.5,
            'upward_adjustment_space': 0.02,
            'downward_adjustment_space': 0.02,
            'historical_best_adjustment': 0.0,
            'price_reachability_score': 0.7,
            'entry_price_quality_score': 0.6,
            # Â∏ÇÂ†¥Áí∞Â¢ÉÁâπÂæµ (9ÂÄã)
            'hour_of_day': 12,
            'trading_session': 1,
            'weekend_factor': 0,
            'symbol_category': 4,
            'current_positions': 0,
            'margin_ratio': 0.5,
            'atr_normalized': 0.01,
            'volatility_regime': 1,
            'market_trend_strength': 0.5
        }
    
    def record_ml_features(self, session_id: str, signal_id: int, features: Dict[str, Any]) -> bool:
        """Ë®òÈåÑMLÁâπÂæµÊï∏Êìö - 36ÂÄãÁâπÂæµÂÆåÊï¥ÁâàÊú¨"""
        try:
            with sqlite3.connect(self.db_path, timeout=30.0) as conn:
                cursor = conn.cursor()
                
                # Ê∫ñÂÇôÊèíÂÖ•Êï∏ÊìöÔºåÁ¢∫‰øùÊâÄÊúâ36ÂÄãÁâπÂæµÈÉΩÊúâÂÄº
                feature_values = [
                    session_id, signal_id,
                    # ‰ø°ËôüÂìÅË≥™Ê†∏ÂøÉÁâπÂæµ (15ÂÄã)
                    features.get('strategy_win_rate_recent', 0.0),
                    features.get('strategy_win_rate_overall', 0.0),
                    features.get('strategy_market_fitness', 0.0),
                    features.get('volatility_match_score', 0.0),
                    features.get('time_slot_match_score', 0.0),
                    features.get('symbol_match_score', 0.0),
                    features.get('price_momentum_strength', 0.0),
                    features.get('atr_relative_position', 0.0),
                    features.get('risk_reward_ratio', 0.0),
                    features.get('execution_difficulty', 0.0),
                    features.get('consecutive_win_streak', 0),
                    features.get('consecutive_loss_streak', 0),
                    features.get('system_overall_performance', 0.0),
                    features.get('signal_confidence_score', 0.0),
                    features.get('market_condition_fitness', 0.0),
                    # ÂÉπÊ†ºÈóú‰øÇÁâπÂæµ (12ÂÄã)
                    features.get('price_deviation_percent', 0.0),
                    features.get('price_deviation_abs', 0.0),
                    features.get('atr_normalized_deviation', 0.0),
                    features.get('candle_direction', 0),
                    features.get('candle_body_size', 0.0),
                    features.get('candle_wick_ratio', 0.0),
                    features.get('price_position_in_range', 0.0),
                    features.get('upward_adjustment_space', 0.0),
                    features.get('downward_adjustment_space', 0.0),
                    features.get('historical_best_adjustment', 0.0),
                    features.get('price_reachability_score', 0.0),
                    features.get('entry_price_quality_score', 0.0),
                    # Â∏ÇÂ†¥Áí∞Â¢ÉÁâπÂæµ (9ÂÄã)
                    features.get('hour_of_day', 0),
                    features.get('trading_session', 0),
                    features.get('weekend_factor', 0),
                    features.get('symbol_category', 0),
                    features.get('current_positions', 0),
                    features.get('margin_ratio', 0.0),
                    features.get('atr_normalized', 0.0),
                    features.get('volatility_regime', 0),
                    features.get('market_trend_strength', 0.0)
                ]
                
                cursor.execute('''
                    INSERT INTO ml_features_v2 (
                        session_id, signal_id,
                        strategy_win_rate_recent, strategy_win_rate_overall, strategy_market_fitness,
                        volatility_match_score, time_slot_match_score, symbol_match_score,
                        price_momentum_strength, atr_relative_position, risk_reward_ratio,
                        execution_difficulty, consecutive_win_streak, consecutive_loss_streak,
                        system_overall_performance, signal_confidence_score, market_condition_fitness,
                        price_deviation_percent, price_deviation_abs, atr_normalized_deviation,
                        candle_direction, candle_body_size, candle_wick_ratio,
                        price_position_in_range, upward_adjustment_space, downward_adjustment_space,
                        historical_best_adjustment, price_reachability_score, entry_price_quality_score,
                        hour_of_day, trading_session, weekend_factor,
                        symbol_category, current_positions, margin_ratio,
                        atr_normalized, volatility_regime, market_trend_strength
                    ) VALUES (
                        ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 
                        ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
                    )
                ''', feature_values)
                
                conn.commit()
                logger.info(f"‚úÖ MLÁâπÂæµË®òÈåÑÊàêÂäü - session_id: {session_id}, signal_id: {signal_id}")
                return True
                
        except Exception as e:
            logger.error(f"‚ùå Ë®òÈåÑMLÁâπÂæµÊôÇÂá∫ÈåØ: {str(e)}")
            return False
    
    def record_signal_quality(self, session_id: str, signal_id: int, quality_data: Dict[str, Any]) -> bool:
        """Ë®òÈåÑML‰ø°ËôüÂìÅË≥™ÂàÜÊûê"""
        try:
            with sqlite3.connect(self.db_path, timeout=30.0) as conn:
                cursor = conn.cursor()
                
                cursor.execute('''
                    INSERT INTO ml_signal_quality (
                        session_id, signal_id, ml_recommendation, confidence_score,
                        execution_probability, trading_probability, risk_level,
                        decision_reason, suggested_price_adjustment, actual_decision
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    session_id, signal_id,
                    quality_data.get('recommendation', 'EXECUTE'),
                    quality_data.get('confidence', 0.5),
                    quality_data.get('execution_probability', 0.5),
                    quality_data.get('trading_probability', 0.5),
                    quality_data.get('risk_level', 'MEDIUM'),
                    quality_data.get('reason', ''),
                    quality_data.get('suggested_price_adjustment', 0.0),
                    'EXECUTE'  # Áï∂ÂâçÈöéÊÆµÁ∏ΩÊòØÂü∑Ë°å
                ))
                
                conn.commit()
                logger.info(f"‚úÖ ML‰ø°ËôüÂìÅË≥™Ë®òÈåÑÊàêÂäü - signal_id: {signal_id}")
                return True
                
        except Exception as e:
            logger.error(f"‚ùå Ë®òÈåÑML‰ø°ËôüÂìÅË≥™ÊôÇÂá∫ÈåØ: {str(e)}")
            return False
    
    def record_price_optimization(self, session_id: str, signal_id: int, 
                                original_price: float, optimized_price: float, 
                                reason: str, confidence: float) -> bool:
        """Ë®òÈåÑMLÂÉπÊ†ºÂÑ™ÂåñÂª∫Ë≠∞"""
        try:
            adjustment_percent = ((optimized_price - original_price) / original_price) * 100
            
            with sqlite3.connect(self.db_path, timeout=30.0) as conn:
                cursor = conn.cursor()
                
                cursor.execute('''
                    INSERT INTO ml_price_optimization (
                        session_id, signal_id, original_price, optimized_price,
                        price_adjustment_percent, optimization_reason, confidence_level
                    ) VALUES (?, ?, ?, ?, ?, ?, ?)
                ''', (
                    session_id, signal_id, original_price, optimized_price,
                    adjustment_percent, reason, confidence
                ))
                
                conn.commit()
                logger.info(f"‚úÖ MLÂÉπÊ†ºÂÑ™ÂåñË®òÈåÑÊàêÂäü - signal_id: {signal_id}")
                return True
                
        except Exception as e:
            logger.error(f"‚ùå Ë®òÈåÑMLÂÉπÊ†ºÂÑ™ÂåñÊôÇÂá∫ÈåØ: {str(e)}")
            return False
    
    def get_ml_table_stats(self) -> Dict[str, int]:
        """Áç≤ÂèñMLË°®Ê†ºÁµ±Ë®à"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                stats = {}
                
                cursor.execute('SELECT COUNT(*) FROM ml_features_v2')
                stats['total_ml_features'] = cursor.fetchone()[0]
                
                cursor.execute('SELECT COUNT(*) FROM ml_signal_quality')
                stats['total_signal_quality'] = cursor.fetchone()[0]
                
                cursor.execute('SELECT COUNT(*) FROM ml_price_optimization')
                stats['total_price_optimization'] = cursor.fetchone()[0]
                
                return stats
                
        except Exception as e:
            logger.error(f"Áç≤ÂèñMLË°®Ê†ºÁµ±Ë®àÊôÇÂá∫ÈåØ: {str(e)}")
            return {'total_ml_features': 0, 'total_signal_quality': 0, 'total_price_optimization': 0}
    
    def get_historical_features_for_ml(self, limit: int = 100) -> List[Dict[str, Any]]:
        """Áç≤ÂèñÊ≠∑Âè≤ÁâπÂæµÊï∏ÊìöÁî®ÊñºMLË®ìÁ∑¥"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Áç≤ÂèñÂÆåÊï¥ÁöÑÁâπÂæµÊï∏ÊìöÂíåÂ∞çÊáâÁöÑ‰∫§ÊòìÁµêÊûú
                cursor.execute('''
                    SELECT 
                        mf.*,
                        tr.is_successful,
                        tr.pnl_percentage,
                        tr.holding_time_minutes,
                        sr.signal_type,
                        sr.symbol,
                        sr.side
                    FROM ml_features_v2 mf
                    JOIN signals_received sr ON mf.signal_id = sr.id
                    LEFT JOIN orders_executed oe ON sr.id = oe.signal_id
                    LEFT JOIN trading_results tr ON oe.id = tr.order_id
                    ORDER BY mf.created_at DESC
                    LIMIT ?
                ''', (limit,))
                
                columns = [description[0] for description in cursor.description]
                results = []
                
                for row in cursor.fetchall():
                    row_dict = dict(zip(columns, row))
                    results.append(row_dict)
                
                logger.info(f"‚úÖ Áç≤ÂèñÂà∞ {len(results)} Ê¢ùMLË®ìÁ∑¥Êï∏Êìö")
                return results
                
        except Exception as e:
            logger.error(f"‚ùå Áç≤ÂèñMLË®ìÁ∑¥Êï∏ÊìöÊôÇÂá∫ÈåØ: {str(e)}")
            return []
    
    def analyze_feature_importance(self) -> Dict[str, float]:
        """ÂàÜÊûêÁâπÂæµÈáçË¶ÅÊÄßÔºàÁ∞°ÂñÆÁâàÊú¨Ôºâ"""
        try:
            historical_data = self.get_historical_features_for_ml(200)
            
            if len(historical_data) < 10:
                logger.warning("Êï∏ÊìöÈáè‰∏çË∂≥ÔºåÁÑ°Ê≥ïÈÄ≤Ë°åÁâπÂæµÈáçË¶ÅÊÄßÂàÜÊûê")
                return {}
            
            # Á∞°ÂñÆÁöÑÁõ∏ÈóúÊÄßÂàÜÊûê
            feature_correlations = {}
            
            success_data = [d for d in historical_data if d.get('is_successful') is not None]
            
            if len(success_data) < 5:
                return {}
            
            # Ë®àÁÆóÊØèÂÄãÁâπÂæµËàáÊàêÂäüÁéáÁöÑÁõ∏ÈóúÊÄß
            feature_names = [
                'strategy_win_rate_recent', 'volatility_match_score', 'time_slot_match_score',
                'symbol_match_score', 'execution_difficulty', 'signal_confidence_score',
                'hour_of_day', 'trading_session', 'symbol_category'
            ]
            
            for feature in feature_names:
                feature_values = [d.get(feature, 0) for d in success_data]
                success_values = [d.get('is_successful', 0) for d in success_data]
                
                if len(set(feature_values)) > 1:  # ÁâπÂæµÊúâËÆäÂåñ
                    correlation = self._calculate_simple_correlation(feature_values, success_values)
                    feature_correlations[feature] = abs(correlation)
            
            return feature_correlations
            
        except Exception as e:
            logger.error(f"ÂàÜÊûêÁâπÂæµÈáçË¶ÅÊÄßÊôÇÂá∫ÈåØ: {str(e)}")
            return {}
    
    def _calculate_simple_correlation(self, x_values: List[float], y_values: List[float]) -> float:
        """Ë®àÁÆóÁ∞°ÂñÆÁõ∏Èóú‰øÇÊï∏"""
        try:
            if len(x_values) != len(y_values) or len(x_values) < 2:
                return 0.0
            
            n = len(x_values)
            sum_x = sum(x_values)
            sum_y = sum(y_values)
            sum_xy = sum(x * y for x, y in zip(x_values, y_values))
            sum_x2 = sum(x * x for x in x_values)
            sum_y2 = sum(y * y for y in y_values)
            
            denominator = ((n * sum_x2 - sum_x * sum_x) * (n * sum_y2 - sum_y * sum_y)) ** 0.5
            
            if denominator == 0:
                return 0.0
            
            correlation = (n * sum_xy - sum_x * sum_y) / denominator
            return correlation
            
        except Exception:
            return 0.0

def create_ml_data_manager(db_path: str) -> MLDataManager:
    """ÂâµÂª∫MLÊï∏ÊìöÁÆ°ÁêÜÂô®ÂØ¶‰æã"""
    return MLDataManager(db_path)
